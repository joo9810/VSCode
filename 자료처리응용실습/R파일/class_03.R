# matrix
m <- matrix(1:16, nrow = 4) #행이 4개
m
m_col <- matrix(1:16, ncol = 4) #열이 4개
m_col
dim(m) #행렬의 행과 열의 수 : 차원(dimension)
dim(m_col)
#전치행령(transpose matrix) : 행과 열을 교환
t(m)
#대각행령
diag(1,nrow=3) #1을 대각선 행으로 3개 채워라
diag(5,nrow=5) #5를 대각선 행으로 5개 채워라
diag(1,2,ncol=3) #???

#행렬 이름 만들기
m1 <- matrix(c(1:9),ncol=3) #1~9까지 열이3개인 매트릭스
m1
rownames(m1) <- c('row1','row2','row3')
colnames(m1) <- c('col1','col2','col3')
m1

#행렬연산 (첫번째 행렬의 열의 갯수와 두번째 행렬의 행의 갯수가 같아야 연산이 된다)
m1+m1 # 3x(3) + (3)x3 (3과 3이 같기 때문에 가능) 중요!!!!!!!!
m1-2*m1 # 위에 내용 행렬내적에만 적용됨. 배열 크기 안맞으면 일반 연산은 안됨.
m1*m1
m1%*%m1 #행렬내적(100퍼 시험출제) (해당하는 행과 열의 원소를 모두 곱해서 더한다)
#만약 (5)x4 와 4x(5)를 행렬내적하면 5x5 매트릭스가 나온다. (시험 출제)

#행렬의 서브세팅 (원소추출)
m1
m1[1,2] #1행 2열에 있는 원소를 추출해라라
m1[2,3]
m1[1:2,2:3] #1행2행과 2열3열을 추출해라
m1[1,] #1행만 출력
m1[,1] #1열만 출력 (출력방향은 행방향)
m1[-1,] #1행을 빼고 출력
m1[,-3] #3열을 빼고 출력
m1[c('row1','row3'),c('col1','col2')]
m1[3:7]

m3 <- matrix(1:6,nrow=2)
m3
m4 <- matrix(1:6,ncol=2)
m4
m3%*%m4
